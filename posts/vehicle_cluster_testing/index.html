<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vehicle cluster simulation | SpeedDragon Blog</title><meta name=keywords content="arduino,esp32"><meta name=description content="How to control a vehicle cluster (speedometer and tachometer) using ESP32 and PWM signals, and fix it in the process. "><meta name=author content><link rel=canonical href=https://speeddragon.github.io/posts/vehicle_cluster_testing/><link crossorigin=anonymous href=/assets/css/stylesheet.5861a6fea64e1e0784f794fd89c8f6fe71ac0528e3d0ef74da2ab896e25be14a.css integrity="sha256-WGGm/qZOHgeE95T9icj2/nGsBSjj0O902iq4luJb4Uo=" rel="preload stylesheet" as=style><link rel=icon href=https://speeddragon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://speeddragon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://speeddragon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://speeddragon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://speeddragon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://speeddragon.github.io/posts/vehicle_cluster_testing/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-7KQHSZCH69"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7KQHSZCH69")}</script><meta property="og:url" content="https://speeddragon.github.io/posts/vehicle_cluster_testing/"><meta property="og:site_name" content="SpeedDragon Blog"><meta property="og:title" content="Vehicle cluster simulation"><meta property="og:description" content="How to control a vehicle cluster (speedometer and tachometer) using ESP32 and PWM signals, and fix it in the process. "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-28T15:16:00+01:00"><meta property="article:modified_time" content="2025-09-28T15:16:00+01:00"><meta property="article:tag" content="Arduino"><meta property="article:tag" content="Esp32"><meta property="og:image" content="https://speeddragon.github.io/images/s13_cluster.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://speeddragon.github.io/images/s13_cluster.jpg"><meta name=twitter:title content="Vehicle cluster simulation"><meta name=twitter:description content="How to control a vehicle cluster (speedometer and tachometer) using ESP32 and PWM signals, and fix it in the process. "><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://speeddragon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Vehicle cluster simulation","item":"https://speeddragon.github.io/posts/vehicle_cluster_testing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vehicle cluster simulation","name":"Vehicle cluster simulation","description":"How to control a vehicle cluster (speedometer and tachometer) using ESP32 and PWM signals, and fix it in the process. ","keywords":["arduino","esp32"],"articleBody":"Disclaimer: I don’t have a degree in electronic engineering. My knowledge comes from reading and experimenting. You should do your own research before trying to replicate my work.\nThe problem Old vehicles start to have issues as they age, and a common one with Nissan 200SX (S13) (240SX in America and 180SX in Japan) is the cluster that stops working, either the speedometer (more common) or the tachometer (engine RPM).\nThe issue with the speedometer is the needle that either stops working or jumps to the other end of the scale (240+ km/h). This is associated with broken solder joints (mainly X1, X2, Y1, Y2) in the speedometer PCB, and usually a reflow (resoldering) is enough to fix.\nI had asked a friend to do this for me, and it fixed the needle moving over 240 km/h issue, but created a new one, where the needle didn’t move after reaching 82 km/h. Why 82 km/h? This took me a long time to understand. Inside the round metal shell, there are 2 coils wrapped in a cross (X) shape. This cross is tilted 45 degrees angle, and the upper limit on this 45 degree angle is 82 km/h.\nSo only one axis was being driven, and the other (from 82 to 270+ km/h) wasn’t able to move the needle. A person even reported only starting to work after 80 km/h, but being erratic after that. That would match the case of only the other axis driving the needle.\nSince then, I’ve improved my soldering skills, so I decided to attempt to fix it by myself, but before doing it, I wanted to come up with a test on the lab to check if it was working properly, before installing it in the car and driving at more than 82 km/h to see if the issue was fixed.\nSince I also had an issue with the tachometer, I also want to simulate this one in the lab to understand what the issue could be.\nTachometer Simulation The first one I’ve tried to simulate was the tachometer. This uses a DC pulse signal from the CAS (Crank Angle Sensor) that happens 2 times per revolution.\nrotations per minute = pulse frequency / 2 * 60 seconds The easy way to do this would be buying a frequency generator, like this. But I didn’t have one, and I also wanted to know how I could change the needle position on a real car gauge, so this was the perfect time to learn how to do it.\nTo simulate this with ESP32 (and with Arduino IDE) I need to send a 12-volt PWM signal at 50% duty cycle. If you don’t know about duty cycle (I didn’t), it is the amount of time the signal is high. In this case, 50% of the time the signal is high and 50% is low.\nThe first thing is to choose a PWM pin. The ESP32 has several PWM pins, so I used the GPIO 4 (D4).\nThe second thing is to transform the 3.3 volts PWM signal to 12 volts. For this I’ve used both BJT transistor and a MOSFET, but for this use case a BJT is enough, since it doesn’t have too much current (under the 600 mA mention in the 2N2222 datasheet).\nAlthough the IRLZ44N works with 3.3v from the ESP32, it will not be fully open, and MOSFETs aren’t meant to be in a transition state, becoming inefficient and generating more heat.\nI decided to use 2N2222 for the BJT transistor (2N3904 would have probably been enough max current to be used as well) to drive the IRFZ44N.\nThe tachometer has 3 pins:\nIGN (ignition, V12+), GND (ground) SIG (signal). I was having some issues understanding how I could send the signal to the tachometer, but this example helped me out.\nHere is the schematics:\nComponents:\nStep-down LM2596 board ESP32 WROOM Devkit 2N2222 IRFZ44N 1kΩ resistor 10kΩ resistor Breadboard and jumper wires (optional, but useful) The code sets 3 RPM values (3000, 6000 and 9000) spaced by 1 second from each other.\n// Define the pin you want to use for PWM int pwmPin = 4; // Example: Using GPIO 4 int ledPin = 2; // Define the PWM channel and frequency int channel = 0; int baseFrequency = 100; // 100 Hz int resolution = 8; // bit resolution void setup() { pinMode(ledPin, OUTPUT); digitalWrite(ledPin, HIGH); // Attach the pin to the channel and set frequency ledcAttach(pwmPin, baseFrequency, resolution); } void loop() { digitalWrite(ledPin, HIGH); // 3000 rpm ledcWriteTone(pwmPin, 100); delay(1000); // 6000 rpm ledcWriteTone(pwmPin, 200); delay(1000); // 9000 rpm ledcWriteTone(pwmPin, 300); digitalWrite(ledPin, LOW); delay(1000); } In this example, I also control the LED pin to know when the ESP32 is running the code. I had some issues with the breadboard I was using, causing the ESP32 to reboot frequently, not being able to understand why I didn’t get the PWM values when running via 12 volts, but working properly when using USB.\nEverything worked as expected, but I couldn’t replicate the same behaviour in another RPM gauge from a Renault 19. I believe that in some cars, they expect a higher signal from the distributor.\nSpeedometer Simulation The speedometer works in a different way than the tachometer. In this vehicle, it uses a 2–wire reluctor speed sensor to provide speed information. This sensor generates an AC signal to the cluster that translates into a Hall effect signal to the ECU.\nThe AC signal changes in amplitude and frequency as the speed increases.\nTo simulate an AC signal with DC, I started to investigate what the options were, but the simplest would be to use a capacitor and a resistor in series to shift the DC square wave signal from the PWM (generated between 0 and 12 volts) to an AC square wave signal (between -6 and 6 volts).\nI used the previous schematic and the base for this one, and added the new components. The new AC signal was 4.7 volts, and I’ve used the previous frequency but added a new step by setting the frequency to 400 Hz. After uploading the code, the needle was moving between 0, 30, and 60 km/h, but didn’t reach the 90 km/h, which was the value I wanted, to replicate the “bug” of not going past 82 km/h.\nThe issue was regarding the voltage not being high enough for the frequency I was using, so I modified the resistor value before the conversion to the AC signal to allow more current to flow. Modifying the 10k ohms to 4.7k ohms was enough, and now the signal was 5.6 volts, enough to reach over 82 km/h.\nFixing speedometer I’ve tried to resolder X1, X2, Y1, and Y2, but it took me a while to fix it. Not sure if the reason was that, or this time I also soldered the IC1 pin (top row, 2 on the left side) that is connected to Y2, which was lacking some solder.\nVideo with the speedometer fixed.\nBut between attempts, I took some time to reverse engineer the device and create the schematics for the speedometer. It was my first time doing schematics and using KiCad, so there were some issues moving things around, and I might have misunderstood some traces. It is also missing some resistor values, for which I didn’t take the time to read the band colors.\nFeel free to submit updates about the schematics in the GitHub repo.\nFor the small capacitor values, I used the ones provided by Shaker783396.\nConclusion It took me 2 weeks to finally fix it, but this was a fun project to take on. All the hours looking into Rossmann repairing Apple Macbooks motherboards made useful now.\nOne cool thing would be to replace this module in the cluster with a custom one that uses more modern electronic and stepper motors instead of coils. There is a guy doing that for the Mazda RX7 (FD). This forum also has a good thread of common issues with these clusters.\n","wordCount":"1339","inLanguage":"en","image":"https://speeddragon.github.io/images/s13_cluster.jpg","datePublished":"2025-09-28T15:16:00+01:00","dateModified":"2025-09-28T15:16:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://speeddragon.github.io/posts/vehicle_cluster_testing/"},"publisher":{"@type":"Organization","name":"SpeedDragon Blog","logo":{"@type":"ImageObject","url":"https://speeddragon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://speeddragon.github.io/ accesskey=h title="SpeedDragon Blog (Alt + H)">SpeedDragon Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://speeddragon.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://speeddragon.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://speeddragon.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://speeddragon.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Vehicle cluster simulation</h1><div class=post-description>How to control a vehicle cluster (speedometer and tachometer) using ESP32 and PWM signals, and fix it in the process.</div><div class=post-meta><span title='2025-09-28 15:16:00 +0100 +0100'>September 28, 2025</span>&nbsp;·&nbsp;7 min</div></header><figure class=entry-cover><img loading=eager src=https://speeddragon.github.io/images/s13_cluster.jpg alt></figure><div class=post-content><p><strong>Disclaimer:</strong> I don&rsquo;t have a degree in electronic engineering. My knowledge comes from reading and experimenting. You should do your own research before trying to replicate my work.</p><h1 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h1><p>Old vehicles start to have issues as they age, and a common one with <a href=https://en.wikipedia.org/wiki/Nissan_Silvia#S13>Nissan 200SX (S13)</a> (240SX in America and 180SX in Japan) is the cluster that stops working, either the speedometer (more common) or the tachometer (engine RPM).</p><p>The issue with the speedometer is the needle that either stops working or jumps to the other end of the scale (240+ km/h). This is associated with broken solder joints (mainly X1, X2, Y1, Y2) in the speedometer PCB, and usually a reflow (resoldering) is enough to fix.</p><p>I had asked a friend to do this for me, and it fixed the needle moving over 240 km/h issue, but created a new one, where the needle didn&rsquo;t move after reaching 82 km/h.
Why 82 km/h? This took me a long time to understand. Inside the round metal shell, there are 2 coils wrapped in a cross (X) shape. This cross is tilted 45 degrees angle, and the upper limit on this 45 degree angle is 82 km/h.</p><p>So only one axis was being driven, and the other (from 82 to 270+ km/h) wasn&rsquo;t able to move the needle. <a href=https://forums.nicoclub.com/how-to-fix-your-analog-speedometer-t623220.html#p6852934>A person</a> even reported only starting to work after 80 km/h, but being erratic after that. That would match the case of only the other axis driving the needle.</p><p>Since then, I&rsquo;ve improved my soldering skills, so I decided to attempt to fix it by myself, but before doing it, I wanted to come up with a test on the lab to check if it was working properly, before installing it in the car and driving at more than 82 km/h to see if the issue was fixed.</p><p>Since I also had an issue with the tachometer, I also want to simulate this one in the lab to understand what the issue could be.</p><h1 id=tachometer-simulation>Tachometer Simulation<a hidden class=anchor aria-hidden=true href=#tachometer-simulation>#</a></h1><p>The first one I&rsquo;ve tried to simulate was the tachometer. This uses a DC pulse signal from the CAS (Crank Angle Sensor) that happens 2 times per revolution.</p><pre tabindex=0><code>rotations per minute = pulse frequency / 2 * 60 seconds
</code></pre><p>The easy way to do this would be buying a frequency generator, like <a href=https://pt.aliexpress.com/item/1005007608787766.html>this</a>. But I didn&rsquo;t have one, and I also wanted to know how I could change the needle position on a real car gauge, so this was the perfect time to learn how to do it.</p><p>To simulate this with ESP32 (and with Arduino IDE) I need to send a 12-volt <a href=https://docs.arduino.cc/learn/microcontrollers/analog-output/>PWM signal</a> at 50% duty cycle. If you don&rsquo;t know about duty cycle (I didn&rsquo;t), it is the amount of time the signal is high. In this case, 50% of the time the signal is high and 50% is low.</p><p><img alt="PWM Duty Cycle" loading=lazy src=/images/pwm.png#center></p><p>The first thing is to choose a PWM pin. The <a href=https://lastminuteengineers.com/esp32-pinout-reference/>ESP32 has several PWM pins</a>, so I used the GPIO 4 (D4).</p><p><img alt="ESP32 WROOM Pinout" loading=lazy src=/images/ESP32-Pinout.webp></p><p>The second thing is to transform the 3.3 volts PWM signal to 12 volts. For this I&rsquo;ve used both BJT transistor and a MOSFET, but for this use case a BJT is enough, since it doesn&rsquo;t have too much current (under the 600 mA mention in the <a href=https://www.alldatasheet.com/datasheet-pdf/view/2138203/SEMTECH/2N2222.html>2N2222 datasheet</a>).</p><p>Although the IRLZ44N works with 3.3v from the ESP32, it will not be fully open, and MOSFETs aren&rsquo;t meant to be in a transition state, becoming inefficient and generating more heat.</p><p>I decided to use 2N2222 for the BJT transistor (2N3904 would have probably been enough max current to be used as well) to drive the IRFZ44N.</p><p>The tachometer has 3 pins:</p><ul><li><code>IGN</code> (ignition, V12+),</li><li><code>GND</code> (ground)</li><li><code>SIG</code> (signal).</li></ul><p>I was having some issues understanding how I could send the signal to the tachometer, but <a href=https://forum.arduino.cc/t/using-esp32-to-control-a-fan-with-pwm-replacing-current-mosfet/1306220/22>this example</a> helped me out.</p><p>Here is the schematics:</p><p><img alt="S13 Tachometer Simulator Schematics" loading=lazy src=/images/s13_tach_sim_schematics.png></p><p>Components:</p><ul><li>Step-down LM2596 board</li><li>ESP32 WROOM Devkit</li><li>2N2222</li><li>IRFZ44N</li><li>1kΩ resistor</li><li>10kΩ resistor</li><li>Breadboard and jumper wires (optional, but useful)</li></ul><p>The code sets 3 RPM values (3000, 6000 and 9000) spaced by 1 second from each other.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Define the pin you want to use for PWM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> pwmPin <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; <span style=color:#75715e>// Example: Using GPIO 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> ledPin <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Define the PWM channel and frequency
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> channel <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> baseFrequency <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>; <span style=color:#75715e>// 100 Hz
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> resolution <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>; <span style=color:#75715e>// bit resolution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setup</span>() 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pinMode</span>(ledPin, OUTPUT);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>digitalWrite</span>(ledPin, HIGH);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Attach the pin to the channel and set frequency
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ledcAttach</span>(pwmPin, baseFrequency, resolution);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>loop</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>digitalWrite</span>(ledPin, HIGH);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3000 rpm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ledcWriteTone</span>(pwmPin, <span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delay</span>(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 6000 rpm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ledcWriteTone</span>(pwmPin, <span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delay</span>(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 9000 rpm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ledcWriteTone</span>(pwmPin, <span style=color:#ae81ff>300</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>digitalWrite</span>(ledPin, LOW);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>delay</span>(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example, I also control the LED pin to know when the ESP32 is running the code. I had some issues with the breadboard I was using, causing the ESP32 to reboot frequently, not being able to understand why I didn&rsquo;t get the PWM values when running via 12 volts, but working properly when using USB.</p><p>Everything worked as expected, but I couldn&rsquo;t replicate the same behaviour in another RPM gauge from a Renault 19. I believe that in some cars, they expect a higher signal from the distributor.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/ai2Ek5qe_34?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h1 id=speedometer-simulation>Speedometer Simulation<a hidden class=anchor aria-hidden=true href=#speedometer-simulation>#</a></h1><p>The speedometer works in a different way than the tachometer. In this vehicle, it uses a 2&ndash;wire reluctor speed sensor to provide speed information. This sensor generates an AC signal to the cluster that translates into a Hall effect signal to the ECU.</p><p>The AC signal changes in amplitude and frequency as the speed increases.</p><p>To simulate an AC signal with DC, I started to investigate what the options were, but the simplest would be to use a capacitor and a resistor in series to shift the DC square wave signal from the PWM (generated between 0 and 12 volts) to an AC square wave signal (between -6 and 6 volts).</p><p>I used the previous schematic and the base for this one, and added the new components. The new AC signal was 4.7 volts, and I&rsquo;ve used the previous frequency but added a new step by setting the frequency to 400 Hz. After uploading the code, the needle was moving between 0, 30, and 60 km/h, but didn&rsquo;t reach the 90 km/h, which was the value I wanted, to replicate the &ldquo;bug&rdquo; of not going past 82 km/h.</p><p>The issue was regarding the voltage not being high enough for the frequency I was using, so I modified the resistor value before the conversion to the AC signal to allow more current to flow. Modifying the 10k ohms to 4.7k ohms was enough, and now the signal was 5.6 volts, enough to reach over 82 km/h.</p><p><img alt="EveryCircuit DC to AC" loading=lazy src=/images/everycircuit_dc_to_ac.png#center></p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/04n3l-273SY?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><h1 id=fixing-speedometer>Fixing speedometer<a hidden class=anchor aria-hidden=true href=#fixing-speedometer>#</a></h1><p>I&rsquo;ve tried to resolder X1, X2, Y1, and Y2, but it took me a while to fix it. Not sure if the reason was that, or this time I also soldered the IC1 pin (top row, 2 on the left side) that is connected to Y2, which was lacking some solder.</p><p><img alt="Resoldering pins" loading=lazy src=/images/s13_speedometer_fix.jpg#center></p><p>Video with the speedometer fixed.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/q30-mUbdzs0?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>But between attempts, I took some time to reverse engineer the device and create the schematics for the speedometer. It was my first time doing schematics and using <a href=https://www.kicad.org/>KiCad</a>, so there were some issues moving things around, and I might have misunderstood some traces. It is also missing some resistor values, for which I didn&rsquo;t take the time to read the band colors.</p><p>Feel free to submit updates about the schematics in the <a href=https://github.com/speeddragon/schematics/tree/main/s13_speedometer>GitHub repo</a>.</p><p><img alt="S13 Speedometer Schematics" loading=lazy src=/images/s13_speedometer_schematics.jpg#center></p><p>For the small capacitor values, I used the ones provided by <a href=https://forums.nicoclub.com/how-to-fix-your-analog-speedometer-t623220.html#p6852934>Shaker783396</a>.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>It took me 2 weeks to finally fix it, but this was a fun project to take on. All the hours looking into <a href="https://www.youtube.com/watch?v=MyKp7fiXkws&amp;list=PLkVbIsAWN2lsHdY7ldAAgtJug50pRNQv0">Rossmann repairing</a> Apple Macbooks motherboards made useful now.</p><p>One cool thing would be to replace this module in the cluster with a custom one that uses more modern electronic and stepper motors instead of coils. There is a guy <a href=https://www.rx7club.com/group-buy-product-dev-fd-rx-7-269/digital-stepper-tachometer-replacement-1160251/>doing that</a> for the Mazda RX7 (FD). This forum also has a <a href=https://www.rx7club.com/3rd-generation-specific-1993-2002-16/troubleshooting-fd-speedometer-odometer-tachometer-circuit-board-1118446/>good thread</a> of common issues with these clusters.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://speeddragon.github.io/tags/arduino/>Arduino</a></li><li><a href=https://speeddragon.github.io/tags/esp32/>Esp32</a></li></ul><nav class=paginav><a class=next href=https://speeddragon.github.io/posts/slow_query/><span class=title>Next »</span><br><span>Postgres - I can't replicate a slow query</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on x" href="https://x.com/intent/tweet/?text=Vehicle%20cluster%20simulation&amp;url=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f&amp;hashtags=arduino%2cesp32"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f&amp;title=Vehicle%20cluster%20simulation&amp;summary=Vehicle%20cluster%20simulation&amp;source=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f&title=Vehicle%20cluster%20simulation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on whatsapp" href="https://api.whatsapp.com/send?text=Vehicle%20cluster%20simulation%20-%20https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on telegram" href="https://telegram.me/share/url?text=Vehicle%20cluster%20simulation&amp;url=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Vehicle cluster simulation on ycombinator" href="https://news.ycombinator.com/submitlink?t=Vehicle%20cluster%20simulation&u=https%3a%2f%2fspeeddragon.github.io%2fposts%2fvehicle_cluster_testing%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://speeddragon.github.io/>SpeedDragon Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>